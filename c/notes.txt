14. Chunks of Bytecode
    
    14.1. Bytecode?
    	
	14.1.1. Why not walk the AST?
	    * AST has already been written AND it's portable due to the JVM
	    * but, it's NOT memory-efficient b/c each piece of syntax 
	      becomes an AST node
	
	14.1.2. Why not compile to native code?
	    * "Native code is a dense series of operations, encoded 
	      directly in binary"
	    * The issues lies in the chip-by-chip specs for native code and
	      the amount of time it takes to learn these specs just for one
	      chip!!!
	
	14.1.3 What is bytecode?
	    * a tree-walk interpreter is simple, portable, but slow
	    * native code is complex, platform-specific, but fast
	    * bytecode resembles machine code
	        - it's a dense, linear sequence of binary instructions
	    * bytecode, itself, runs on an emulator: a simulated chip 
	      written in software that interprets the bytecode, a VM
	      (virtual machine)
	    * in jlox, we wrote a parser for the front end, syntax trees
	      for the representation, and an interpreter for execution
	    * in clox, we will write a compiler for the front end, byte-
	      code for the representation, and a VM for execution
    
    14.2 Getting Started
        * Added `main()` in main.c
	* Added a handful of useful types and constants into common.h

    14.3 Chunks of Instructions
        * Added chunk.h and chunk.c to represent sequences of bytecode
	* Added opcodes as an emum to chunk.h
	    - added OP_RETURN, which will eventually come to mean
	       "return from current function"
	
	14.3.1. A dynamic array of instructions
	    * bytecode is a series of instructions
	    * eventually, we'll store other data along w/ the instructions
	    * creating the Chunk struct in chunk.h to hold it all
	    * Chunk is essentially a dynamic array data structure
	        - dynamic arrays provide:
		    i. cache-friendly, dense storage
		    ii. constant-time indexed element lookup
		    iii. constant-time appending to the end of the array
		- dynamic arrays involve the use of tracking # of elements
		  allocated (capacity) and how many of those elements are
		  in use (count)
